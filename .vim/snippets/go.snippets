snippet max "function for max"
	func max(s ...${1:int}) $1 {
		maxContent := s[0]
		for _, el := range s {
			if el > maxContent {
				maxContent = el
			}
		}
		return maxContent
	}
	${0}

snippet min "function for min"
	func min(s ...${1:int}) $1 {
		minContent := s[0]
		for _, el := range s {
			if el < minContent {
				minContent = el
			}
		}
		return minContent
	}
	${0}

snippet packm "snippet for main"
	package main

	func main() {
		${1}
	}${0}

snippet stack "stack"
	type stack []${1:int}

	func (s stack) Push(p $1) stack {
		return append(s, p)
	}

	func (s stack) Pop() ($1, stack) {
		return s[len(s)-1], s[:len(s)-1]
	}
	${0}

snippet queue "queue"
	type queue []${1:int}

	func (q queue) Push(p $1) queue {
		return append(q, p)
	}

	func (q queue) Pop() ($1, queue) {
		if len(q) == 1 {
			return q[0], make(queue, 0)
		}
		return q[0], q[1:]
	}

snippet unionFind "Union find"
	type unionTree struct {
		el     int
		parent *unionTree
	}

	func (u *unionTree) root() *unionTree {
		if u.parent == nil {
			return u
		}

		root := u.parent.root()
		if root != u.parent {
			u.parent = root
		}
		return root
	}

	func (u *unionTree) same(v *unionTree) bool {
		return u.root() == v.root()
	}

	func (u *unionTree) unite(v *unionTree) {
		uRoot := u.root()
		vRoot := v.root()
		if uRoot == vRoot {
			return
		}

		if uRoot.el < vRoot.el {
			vRoot.parent = uRoot
		} else {
			uRoot.parent = vRoot
		}
	}
	${0}
